## constants ##

# log threshold values
LOG_DEBUG=0
LOG_VERBOSE=2
LOG_QUIET=6
LOG_FORCE=9  # force write regardless of VERBOSE setting

# log file path
LOGFILE='/var/log/rhs-hadoop-install.log'

## functions ##

# check_ssh: verify that the user can passwordless ssh to the passed-in list of
# nodes. Returns 1 on errors.
# Args: $@ = list of nodes.
function check_ssh() {

  local nodes="$@"
  local node; local err; local errcnt=0

  for node in $nodes; do
      [[ "$node" == "$HOSTNAME" ]] && continue # skip
      ssh -q $node exit
      err=$?
      if (( err != 0 )) ; then
        echo "ERROR: cannot passwordless ssh to node $node from $HOSTNAME"
        ((errcnt++))
      fi
  done

  (( errcnt > 0 )) && return 1
  return 0
}

# currentClusterName: returns the name of the current ambari cluster. Returns
# 1 on errors. 
# Args: $1=ambari server hostname (including :port),
#       $2=ambari admin username,
#       $3=ambari user password.
function currentClusterName() {

  local url="$1"; local user="$2"; local pass="$3"
  local name

  name="$(curl -s -u $user:$pass "$url/api/v1/clusters/" | grep cluster_name)"
  name="${name%,}"    # remove trailing comma if present
  name="${name#*: }"  # extract cluster name value
  name="${name//\"/}" # remove double-quotes

  [[ -z "$name" ]] && {
    echo "ERROR: cluster name not found"; return 1; }

  echo "$name"
  return 0
}

# debug: call display() using LOG_DEBUG. $1 can be an echo option or the msg.
# "DEBUG" is prepended to the msg.
function debug() {

  local opt=''
  if (( ${#1} == 2 )) && [[ ${1:0:1} == '-' && ${1:1:1} =~ [a-z] ]] ; then
    opt="$1"; shift # assume echo option
  fi
  display $opt "DEBUG: $1" $LOG_DEBUG
}

# default_nodes: Detects if any/all of the supplied *_node options have been 
# omitted and prompts the user to confirm if they wish to use localhost as 
# the missing node's default value. Following each option is its human readable
# name, eg 'MGMT_NODE' 'management'. Returns 1 if the answer is no.
# Note: the *name* of the variable is passed not its value.
# Note: the node variable is set to HOSTNAME if the user answers yes.
# Uses globals:
#   AUTO_YES
function default_nodes() {

  local varname; local human_name; local node

  while (( $# > 0 )) ; do
    varname=$1; node=${!varname}; human_name="$2"
    if [[ -z "$node" ]] ; then # node omitted
      echo "No $human_name node specified therefore the localhost ($HOSTNAME) is assumed"
      (( ! AUTO_YES )) && ! yesno  "  Continue? [y|N] " && return 1
      eval $varname="$HOSTNAME"
    fi
    shift 2
  done

  return 0
}

# display: append the passed-in message to localhost's logfile, and potentially
# write the message to stdout, depending on the value of the passed-in priority
# setting. A timestamp is prepended to the logfile msg.
# NOTE: $LOGFILE must be defined if logging is desired.
# NOTE: $VERBOSE should be defined if "threshold" echos are desired.
#   $1="-n" or "-e" other echo option, or if no option then $1 = msg,
#   $2=msg prioriy, optional, default=$LOG_QUIET,
#   $3=logfile,     optional, default=$LOGFILE.
function display() {

  local opt=''
  if (( ${#1} == 2 )) && [[ ${1:0:1} == '-' && ${1:1:1} =~ [a-z] ]] ; then
    opt="$1"; shift # assume echo option
  fi

  local pri=${2:-$LOG_QUIET} # default msg priority
  local log=${3:-$LOGFILE}
  local verbose=${VERBOSE:-$LOG_DEBUG} # if VERBOSE not set then always echo msg

  [[ -n "$log" ]] && echo "[$(date +%T)] $1" >> $log
  (( pri >= verbose )) && echo $opt "$1"
}

# err: call force(). Prepend "ERROR" to msg.
# $1= echo option or next arg,
# $2= error number or next arg,
# $3= message.
function err() {

  local num=''; local opt=''
  if (( ${#1} == 2 )) && [[ ${1:0:1} == '-' && ${1:1:1} =~ [a-z] ]] ; then
    opt="$1"; shift # assume echo option
  fi
  [[ "$1" == *[!0-9]* ]] || { num=" $1"; shift; } # assume 1st arg is error num

  force $opt "ERROR$num: $1"
} 

# force: call display() using LOG_FORCE. $1 can be echo option(s) or the msg.
function force() {

  local opt=''
  if (( ${#1} == 2 )) && [[ ${1:0:1} == '-' && ${1:1:1} =~ [a-z] ]] ; then
    opt="$1"; shift # assume echo option
  fi
  display $opt "$1" $LOG_FORCE
}

# get_ambari_repo: wget the ambari repo file in the correct location.
# Returns 1 on errors.
function get_ambari_repo(){
 
  local REPO_DIR='/etc/yum.repos.d'; local REPO_FILE='ambari.repo'
  local REPO_URL='http://public-repo-1.hortonworks.com/ambari/centos6/1.x/updates/1.6.1/ambari.repo' # hdp 2.1
  local out; local err

  [[ -d $REPO_DIR ]] || mkdir -p $REPO_DIR

  # 20 sec max time, overwrites existing repo
  out="$(wget --timeout 20 -O $REPO_DIR/$REPO_FILE $REPO_URL 2>&1)"
  err=$?
  if (( err != 0 )) ; then
    echo "ERROR $err: ambari repo wget: $out"
    return 1
  fi

  return 0
}

# gluster_mnt_vol: on localhost, persist the passed-in volume, node, and mount
# as a native glusterfs-fuse mount with the correct owner and permissions.
# Returns the exit-code from the mount command.
# Note: the order of mounting first then setting perms and owner matters!
# Note: _netdev is appended to the mount opts.
# Args:
#   1=storage node
#   2=volume name
#   3=gluster vol mount dir (includes volname)
#   4=(optional) mount opts
function gluster_mnt_vol() {

  local node=$1; local vol=$2; local mnt=$3; local mntopts=$4
  local owner="yarn:hadoop" # assumes both have been created!
  local perms=0755 # rwxr-xr-x
  local prefix; local err=0

  # append to fstab if not present
  if ! grep -qs $mnt /etc/fstab ; then # mnt not present in fstab
    if [[ -z "$mntopts" ]] ; then # set default mount opts
      prefix="$(dirname $BASH_SOURCE)" # sourced functions file dir
      mntopts="$($prefix/gen_vol_mnt_options.sh)" # required mnt opts
    fi
    mntopts+=',_netdev' # always append _netdev
    # persist mnt in fstab
    echo $node:/$vol $mnt glusterfs $mntopts 0 0 >>/etc/fstab
  fi

  # create the mount dir
  mkdir -p $mnt 2>&1

  # mount the vol if not already mounted. MUST be done before chmod/chown!
  if (( err == 0 )) && ! grep -qs $mnt /proc/mounts ; then
    mount $mnt 2>&1
    err=$?
    (( err == 32 )) && err=0 # 32==already mounted
  fi

  if (( err == 0 )) ; then
    # set owner/perms *after* mounting
    chmod $perms $mnt 2>&1 && chown $owner $mnt 2>&1
    err=$?
  fi

  return $err
}

# quiet: call display() using LOG_QUIET. $1 can be an echo option or the msg.
function quiet() {

  local opt=''
  if (( ${#1} == 2 )) && [[ ${1:0:1} == '-' && ${1:1:1} =~ [a-z] ]] ; then
    opt="$1"; shift # assume echo option
  fi
  display $opt "$1" $LOG_QUIET
}

# setup_firewall: due to random ports (ports opened with port num 0) and
# possibly RMI ports we cannot open up the firewall only for specific hadoop / 
# gluster / ambari related ports. The only solution that allows hadoop to work
# is to open up the entire firewall. If customers want security then they'll 
# need to establish cluster perimeter security, liklely on a separate, private
# network. Returns 1 on errors.
function setup_firewall() {

  local err

  iptables -F		  && \
    service iptables stop && \
    service iptables save && \
    chkconfig iptables off # persist setting

  err=$?
  (( err != 0 )) && {
     echo "ERROR $err: iptables";
     return 1; }

  echo "iptables configured and saved"
  return 0
}

# setup_selinux: set selinux on localhost to permissive mode, which seems to be
# a HDP requirement. Persist this setting. Returns 1 on errors.
function setup_selinux() {

  local err
  local conf='/etc/sysconfig/selinux' # symlink to /etc/selinux/config
  local selinux_key='SELINUX='
  local permissive='permissive'

  # set selinux to permissive (audit errors reported but not enforced)
  setenforce $permissive 2>&1

  # keep selinux permissive on reboots
  if [[ ! -f $conf ]] ; then
    echo "WARN: SELinux config file $conf missing"
    return # nothing more to do...
  fi

  # config SELINUX=permissive which takes effect the next reboot
  sed -i -e "/^$selinux_key/c\\$selinux_key$permissive" $conf
  err=$?
  if (( err != 0 )) ; then
    echo "ERROR $err: trying to set selinux to permissive in $conf"
    return 1
  fi
}

# uniq_nodes: output the unique nodes from the list of nodes provided.
# $@=list of nodes.
function uniq_nodes() {

  local node; local uniq=()
 
  for node in $@; do
      [[ "${uniq[*]}" =~ $node ]] && continue
      uniq+=($node)
  done

  echo "${uniq[*]}"
}

# validate_ntp_conf: validate the ntp config file by ensuring there is at least
# one time-server suitable for ntp use. Return 1 for errors.
function validate_ntp_conf(){

  local timeserver; local i=1; local errcnt=0
  local ntp_conf='/etc/ntp.conf'
  local servers=(); local numServers

  if [[ ! -f $ntp_conf ]] ; then
    echo "ERROR: ntp config file \"$ntp_conf\" is missing"
    return 1 # nothing more we can do...
  fi

  servers=($(grep "^ *server " $ntp_conf|awk '{print $2}')) # time-servers
  numServers=${#servers[@]}

  if (( numServers == 0 )) ; then
    echo "ERROR: no server entries in $ntp_conf"
    ((errcnt++))
  fi

  for timeserver in ${servers[@]} ; do
      ntpdate -q $timeserver >& /dev/null
      (( $? == 0 )) && break # exit loop, found valid time-server
      ((i++))
  done
  if (( i > numServers )) ; then
    echo "ERROR: no suitable time-servers found in $ntp_conf"
    ((errcnt++))
  fi

  (( errcnt > 0 )) && return 1
  echo "NTP time-server $timeserver is acceptable"
  return 0
}

# verbose: call display() using LOG_VERBOSE. $1 can be echo option(s) or the msg.
function verbose() {

  local opt=''
  if (( ${#1} == 2 )) && [[ ${1:0:1} == '-' && ${1:1:1} =~ [a-z] ]] ; then
    opt="$1"; shift # assume echo option
  fi
  display $opt "$1" $LOG_VERBOSE
}

# verify_gid_uids: checks that the UIDs and GIDs for the hadoop users and hadoop
# group are the same numeric value across all of the passed-in nodes. Returns 1
# on inconsistency errors.
function verify_gid_uids() {

  local nodes="$@"
  local errcnt=0; local out; local err
  local prefix="$(dirname $BASH_SOURCE)" # sourced functions file dir

  verbose "--- verifying consistent hadoop UIDs and GIDs across nodes..."

  out="$($prefix/check_gids.sh $nodes)"
  err=$?
  debug "check_gids: $out"
  if (( err != 0 )) ; then
    ((errcnt++))
    err -e "inconsistent GIDs:\n$out"
  fi

  out="$($prefix/check_uids.sh $nodes)"
  err=$?
  debug "check_uids: $out"
  if (( err != 0 )) ; then
   ((errcnt++))
    err -e "inconsistent UIDs:\n$out"
  fi

  (( errcnt > 0 )) && return 1
  verbose "--- completed verifying hadoop UIDs and GIDs"
  return 0
}

# vol_exists: invokes gluster vol info to see if VOLNAME exists. Returns 1 on
# errors. 
# Args:
#   $1=volume name,
#   $2=any storage node where gluster cli can be run.
function vol_exists() {

  local vol="$1"; local rhs_node="$2"
  local ssh

  [[ "$rhs_node" == "$HOSTNAME" ]] && ssh='' || ssh="ssh $rhs_node"

  eval "$ssh gluster volume info $VOLNAME >& /dev/null"
  (( $? != 0 )) && return 1
  return 0
}

# warn: call force(). Prepend "WARN" and optional warn number to msg.
# $1= echo option or next arg,
# $2= warning number or next arg,
# $3= message.
function warn() {

  local num=''; local opt=''
  if (( ${#1} == 2 )) && [[ ${1:0:1} == '-' && ${1:1:1} =~ [a-z] ]] ; then
    opt="$1"; shift # assume echo option
  fi
  [[ "$1" == *[!0-9]* ]] || { num=" $1"; shift; } # assume 1st arg is warn num

  force $opt "WARN$num: $1"
} 

# yesno: prompts $1 to stdin and returns 0 if user answers yes, else returns 1.
# The default (just hitting <enter>) is specified by $2.
# $1=prompt (required),
# $2=default (optional): 'y' or 'n' with 'n' being the default default.
function yesno() {

  local prompt="$1"; local default="${2:-n}" # default is no
  local yn

   while true ; do
       read -p "$prompt" yn
       case $yn in
	 [Yy])         return 0;;
	 [Yy][Ee][Ss]) return 0;;
	 [Nn])         return 1;;
	 [Nn][Oo])     return 1;;
	 '') # default
	   [[ "$default" != 'y' ]] && return 1 || return 0
	 ;;
	 *) # unexpected...
	   echo "Expecting a yes/no response, not \"$yn\""
	 ;;
       esac
   done
}
